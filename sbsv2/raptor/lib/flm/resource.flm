# Copyright (c) 2007-2010 Nokia Corporation and/or its subsidiary(-ies).
# All rights reserved.
# This component and the accompanying materials are made available
# under the terms of the License "Eclipse Public License v1.0"
# which accompanies this distribution, and is available
# at the URL "http://www.eclipse.org/legal/epl-v10.html".
#
# Initial Contributors:
# Nokia Corporation - initial contribution.
#
# Contributors:
#
# Description:
# Function Like Makefile (FLM) to create a resource header (.rsg)
# and resource files (.rsc, .r01, .r02 etc.)
#
#

## Parameters that are expected:
# TARGET
# TARGETPATH
# LANGUAGES
# HEADER
# HEADERONLY
# EPOCROOT
# MMPDEFS
# PRODUCT_INCLUDE
# SYSTEMINCLUDE
# USERINCLUDE
# GNUCPP
# GNUSED
# RCOMP
# OUTPUTPATH
# SOURCE
# BINCOPYDIRS


# The rss is pre-processed once for each language and results
# in a file with extension r$(LANGUAGE) where $(LANGUAGE) is
# either "sc" or a 2 (or more) digit number.
ifneq ($(TARGETPATH),)
RSCDIR:=$(subst //,/,$(EPOCROOT)/epoc32/data/z/$(TARGETPATH))
else
RSCDIR:=$(subst //,/,$(EPOCROOT)/epoc32/data)
endif
RESBASE:=$(RSCDIR)/$(TARGET_lower)

# Ensure that RELEASABLES and CLEANTARGETS cannot expand indefinitely in successive calls to this flm:
CLEANTARGETS:=
RELEASABLES:=
CREATABLEPATHS:=

# There is only one resource header (.rsg) file and we only
# make that if we are asked.
RSGDIR:=$(EPOCROOT)/epoc32/include
# If there are multiple LANGUAGES then it is the last one in the list
# which produces the header.
HEADLANG:=$(lastword $(LANGUAGES:SC=sc))
ifneq ($(or $(HEADER),$(HEADERONLY)),)
        RESOURCEHEADER:=$(RSGDIR)/$(HEADER)

else
        RESOURCEHEADER:=
endif

# we create intermediate .rpp and .d files
INTERBASE_TMP:=$(OUTPUTPATH)/$(TARGET_lower)_$(notdir $(basename $(SOURCE)))
INTERBASE:=$(OUTPUTPATH)/$(TARGET_lower)

# common pre-processor options

# We really should be using -iquote with a recent cpp.  This is a note for when we do update:
#CPPOPT:=-nostdinc -undef -Wno-trigraphs -D_UNICODE -include $(PRODUCT_INCLUDE)\
# -I$(dir $(SOURCE)) $(foreach I, $(USERINCLUDE),-iquote $(I) ) $(foreach J,$(SYSTEMINCLUDE),-I $(J) )

CPPOPT:=-nostdinc -undef -Wno-trigraphs -D_UNICODE -include $(PRODUCT_INCLUDE)\
 -I$(dir $(SOURCE)) $(foreach I, $(USERINCLUDE),-I$(I) ) -I- $(foreach J,$(SYSTEMINCLUDE),-I$(J) )

CREATABLEPATHS:=$(CREATABLEPATHS) $(RSCDIR) $(RSGDIR) $(OUTPUTPATH) $(INTERBASE_TMP) $(INTERBASE)

# We intend to generate the resource in an intermediate location and copy to the targetpath to
# ensure that when the "same" resource is built into separare target paths, it doesn't have to be 
# completely recreated each time - just copied.
RSCCOPYDIRS:=$(RSCDIR)

# additional binary resource copies performed based on BINCOPYDIRS
ifneq ($(BINCOPYDIRS),)
        RSCCOPYDIRS:=$(RSCCOPYDIRS) $(subst //,/,$(patsubst %,%/$(if $(TARGETPATH),/z/$(TARGETPATH),),$(BINCOPYDIRS)))
endif
CREATABLEPATHS:=$(CREATABLEPATHS) $(RSCCOPYDIRS)

###############################################################################


define preprocessresource
# $(1) is the RPPFILE		(eg. /epoc32/build/xxx/b_sc.rpp)
# $(2) is the related RESOURCEFILE if any (eg. /a/b.rsc)
# $(3) is the LANGUAGE		(eg. sc or 01 or 02 ...)
# $(4) is the "primary" language on which all the others depend

  ifeq ($(TARGET_$(call sanitise,$1)),)
    TARGET_$(call sanitise,$1):=1
    $(if $(FLMDEBUG),$$(info <debug>preprocessresource: $(1) for $(2) LANG:$(3) dep $(4)</debug>))


    # Correct dependency information when a header file can't be found.
    # If the c preprocessor can't find a dependency it appears as it did in the #include statement
    # e.g. "filename.mbg" or "filename.rsg" in the dependency file.

ifneq ($(NO_DEPEND_GENERATE),)
    # This version minimises the size of dependency files, to contain only .mbg and .rsg deps.
    # It allows resources to be built in the right order but doesn't impose the weight of
    # of full dependency information which can overwhelm make in large builds.
    # The strategy is filter lines which don't have .rsg or 
    # .mbg dependencies in them and if to sift each line to leave out non-relevant things like
    # other header files, .hrh files etc.  In the end we don't print anything at all if we
    # did not find the target.

define  DEPENDENCY_CORRECTOR
{ set +x; $(GNUSED) -rn '\% ([^ /]+)\.((rsg)|(mbg))%I {y/\\/ /;p;}'  |  \
    { \
    DEPTXT="$$$$RPP: \\\\\n"; \
    DEPCOUNT=0; \
    DEPS=''; read L; \
    while [ $$$$? -eq 0 ]; do \
        for i in $$$${L}; do \
          if [[ ( "$$$${i%%.[Rr][Ss][Gg]}" != "$$$$i"  || "$$$${i%%.[Mm][Bb][Gg]}" != "$$$$i" ) && ( "$$$${i:1:1}" != ':' && "$$$${i:0:1}" != '/' ) ]];  then \
            DEPTXT="$$$$DEPTXT \$$$$(EPOCROOT)/epoc32/include/$$$$i \\\\\n"; \
            (( DEPCOUNT += 1 )) ; \
          fi; \
        done; \
      read L; \
    done; \
    if [ $$$$DEPCOUNT -ne 0 ]; then  echo -e "$$$${DEPTXT%%\\\\\\n}\n"; fi ;\
  } ;\
} 
endef

else
    # This can correct the dependencies by assuming that the file will be in epoc32\include as this is the default
    DEPENDENCY_CORRECTOR:=$(GNUSED)  -r 's% ([^ \/]+\.((rsg)|(mbg)))% $(EPOCROOT)\/epoc32\/include\/\1%ig' 
endif


    ifeq "$1" "$4"
        RESOURCE_DEPS:: $1.d

        $1.d: $(SOURCE)
	  $(call startrule,resourcedependencies,FORCESUCCESS) \
	  RPP=$1; $(GNUCPP) -DLANGUAGE_$(3) -DLANGUAGE_$(subst sc,SC,$3) $(call makemacrodef,-D,$(MMPDEFS))\
	  $(CPPOPT) $(SOURCE) -M -MG -MT"$1" | \
	  $$(DEPENDENCY_CORRECTOR) >$$@ \
	  $(call endrule,resourcedependencies)

         $1 : $1.d

    else
         $1 : $4
    endif

    $1:
	  $(call startrule,resourcepreprocess,FORCESUCCESS) \
	  $(GNUCPP) -C -DLANGUAGE_$3 -DLANGUAGE_$(subst sc,SC,$(3)) $(call makemacrodef,-D,$(MMPDEFS))\
	  $(CPPOPT) $(SOURCE) -o $$@ \
	  $(call endrule,resourcepreprocess)
    endif

    CLEANTARGETS:= $$(CLEANTARGETS) $1

    ifeq "$(MAKEFILE_GROUP)" "RESOURCE"
    ifeq "$1" "$4"
      $(eval DEPENDFILENAME:=$1.d)
      $(eval DEPENDFILE:=$(wildcard $(DEPENDFILENAME)))
      
      CLEANTARGETS:=$$(CLEANTARGETS) $(DEPENDFILENAME)
      ifneq "$(DEPENDFILE)" ""
        ifeq "$(filter %CLEAN,$(call uppercase,$(MAKECMDGOALS)))" ""
          ifeq "$(MAKEFILE_GROUP)" "RESOURCE"
           -include $(DEPENDFILE)
          endif
        endif
      endif
    endif

  endif
endef # preprocessresource #

###############################################################################
define copyresource
# $(1) is the source
# $(2) is the space separated list of destinations which must be filenames

   RELEASABLES:=$$(RELEASABLES) $(2)

   $(info <copy source='$1'>$(foreach T,$2,$(if $(TARGET_$(call sanitise,$(T))),,$(T)$(eval TARGET_$(call sanitise,$(firstword $2)):=1)))</copy>)
 
endef # copyresource #

###############################################################################
define generateresource

# $(1) is the resource filename e.g. /a/b/resource.rsc
# $(2) is the preprocessed resource to make it from
# $(3) is the language e.g. sc or 01 or 02


        ifeq ($(TARGET_$(call sanitise,$1)),)
                TARGET_$(call sanitise,$1):=1

            $(if $(FLMDEBUG),$(info <debug>generateresource: $(1) from $(2) LANG:$(3)</debug>),)	
            $(if $(FLMDEBUG),$(info <debug>generateresource: copies: $(sort $(patsubst %,%/$(notdir $(1)),$(RSCCOPYDIRS)))</debug>))

            CLEANTARGETS:=$$(CLEANTARGETS) $(1)

            RESOURCE:: $(1)

            $(1): $(2) $(RCOMP)
			$(call startrule,resourcecompile,FORCESUCCESS) \
			$(RCOMP) -m045,046,047 -u -o$(1) -s$(2)  \
			$(call endrule,resourcecompile)

        endif

#	Whether or not we have generated this resource for some other variant, check if there
#       are any new copies to be made for this variant. e.g. winscw requires that we make
#       some extra copies.  We tried to copy after running rcomp itself but we still need these
#       targets for the sake of dependencies or, for example if someone merely adds a new copy 
#       when the resource is up-to-date

        $(call copyresource,$1,$(sort $(patsubst %,%/$(notdir $1),$(RSCCOPYDIRS))))


        # individual source file compilation
        SOURCETARGET_$(call sanitise,$(SOURCE)): $(1)

endef # generateresource


###############################################################################
define generateresourceheader
# $(1) is the resource header	(eg. /epoc32/include/a.rsg)
# $(2) is the preprocessed resource to make it from
# $(3) is the language to use	(eg. sc)

        RELEASABLES:= $$(RELEASABLES) $(1)

        ifeq ($(TARGET_$(call sanitise,$1)),)
                TARGET_$(call sanitise,$1):=1
                $(if $(FLMDEBUG),$(info <debug>resourceheader: $(1) from $(2) LANG:$(3)</debug>))

                RESOURCE:: $(1)

                $(1): $(2) $(RCOMP)
			$(call startrule,resourceheader,FORCESUCCESS) \
			$(RCOMP) -m045,046,047 -u -h$(1) -s$(2) \
			$(call endrule,resourceheader)

        endif


        # individual source file compilation
        SOURCETARGET_$(call sanitise,$(SOURCE)): $(1)

endef

###############################################################################
## call the generator

# We always create at least the header
# even if we sometimes don't create the resources
ifneq ($(RESOURCEHEADER),)
        $(eval $(call generateresourceheader,$(RESOURCEHEADER),$(INTERBASE_TMP)_$(HEADLANG).rpp,$(HEADLANG)))
endif

# The one on which the others will depend i.e. they will 
# "sit in it's dependency slipstream" or in other words
# We only have to make one dependency file because all of
# the other languages will benefit from this languages'
# dependency file
PRIMARYRPPFILE:=$(INTERBASE_TMP)_$(HEADLANG).rpp
ifeq ($(HEADERONLY),)
        # generate a resource file for each language
        # For sc we generate $(RESBASE).rsc and define LANGUAGE_SC and LANGUAGE_sc.
        $(foreach L,$(LANGUAGES:SC=sc),$(eval $(call preprocessresource,$(INTERBASE_TMP)_$(L).rpp,$(INTERBASE).r$(L),$(L),$(PRIMARYRPPFILE))))

        ifeq "$(MAKEFILE_GROUP)" "RESOURCE"
            $(foreach L,$(LANGUAGES:SC=sc),$(eval $(call generateresource,$(INTERBASE).r$(L),$(INTERBASE_TMP)_$(L).rpp,$(L))))
        endif
else
        # No resources are going to be made so unless we specifically ask for it, there will be no
        # preprocessed file from which to create the header:

        $(eval $(call preprocessresource,$(INTERBASE_TMP)_$(HEADLANG).rpp,,$(HEADLANG),$(PRIMARYRPPFILE)))

endif

###############################################################################
## .rfi generation in support of the gccxml build
## Note that .rfi files are created from the dependency files generated from preprocessing resources to create .rpp files
ifneq ($(RFIFILE),)
  RESOURCE:: $(RFIFILE)
  RELEASABLES:=$(RELEASABLES) $(RFIFILE)
  CREATABLEPATHS:=$(CREATABLEPATHS) $(dir $(RFIFILE))/

  RPPFILES:=$(foreach L,$(LANGUAGES:SC=sc),$(INTERBASE_TMP)_$(L).rpp)
  #$(eval $(call generaterfifile,$(RFIFILE),$(RPPFILES),$(addsuffix .d,$(RPPFILES))))
endif


## Clean up
$(call raptor_clean,$(CLEANTARGETS))
# make the output directories while reading makefile - some build engines prefer this
$(call makepath,$(CREATABLEPATHS))

# for the --what option and the log file
RELEASABLES:=$(RELEASABLES) $(DESTRPP) $(INFOFILE)
$(call raptor_release,$(RELEASABLES),RESOURCE)

