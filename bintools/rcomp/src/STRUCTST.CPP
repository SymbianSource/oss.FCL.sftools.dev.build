/*
* Copyright (c) 1997-2009 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of the License "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description: 
*
*/


#include <assert.h>
#include <stdlib.h>
#include "STRUCTST.H"
#include "RESOURCE.H"
#include "TOKENS.H"  
#include "ERRORHAN.H"

// StructItem

StructItem::StructItem(String aLabelToSet):
	iLabel(aLabelToSet)
	{}

StructItem::~StructItem()
	{}

StructItem::StructItem(StructItem& /*aSource*/): ArrayItem()
	{
	assert(0);
	}

// SimpleStructItem

SimpleStructItem::SimpleStructItem(DataType aItemTypeToSet,String aLabelToSet):
	StructItem(aLabelToSet),
	iItemType(aItemTypeToSet)
	{
	switch(iItemType)
		{
		case L_BYTE:
		case L_WORD:
		case L_LONG:
			iDefault = "0";
			break;
		case L_DOUBLE:
			iDefault = "0.0";
			break;
		}
	}

SimpleStructItem::SimpleStructItem(DataType aItemTypeToSet,String aLabelToSet,String aMaxLength):
	StructItem(aLabelToSet),
	iItemType(aItemTypeToSet),
	iLengthLimit(aMaxLength)
	{
	switch(iItemType)
		{
		case L_BYTE:
		case L_WORD:
		case L_LONG:
			iDefault = "0";
			break;
		case L_DOUBLE:
			iDefault = "0.0";
			break;
		}
	}

ResourceItem* SimpleStructItem::NewResourceItem()
	{
	SimpleResourceItem* item=new SimpleResourceItem(this);
	return(item);
	}

SimpleStructItem::~SimpleStructItem()
	{}

SimpleStructItem::SimpleStructItem(SimpleStructItem& aSource):
	StructItem(aSource)
	{
	assert(0);
	}

SimpleStructItem& SimpleStructItem::operator=(SimpleStructItem& /*Source*/)
	{
	assert(0);
	return *this;
	}

// ArrayStructItem

ArrayStructItem::ArrayStructItem(DataType aItemTypeToSet,String aLabelToSet):
	StructItem(aLabelToSet),
	iItemType(aItemTypeToSet),
	iLenType(0)
	{}

ArrayStructItem::~ArrayStructItem()
	{
	iDefaults.DeleteAll();
	}

ResourceItem * ArrayStructItem::NewResourceItem()
	{
	return new ArrayResourceItem( this);
	}

// StructTypeStructItem

StructTypeStructItem::StructTypeStructItem(String aLabelToSet):
	StructItem(aLabelToSet)
	{}

ResourceItem * StructTypeStructItem::NewResourceItem()
	{
	return new StructTypeResourceItem( this);
	}

// StructArrayStructItem

StructArrayStructItem::StructArrayStructItem(String aLabelToSet):
	StructItem(aLabelToSet),
	iLenType(0)
	{}

StructArrayStructItem::StructArrayStructItem(String aLabelToSet,String aSizeToSet):
	StructItem(aLabelToSet),
	iLenType(0),
	iSize(aSizeToSet)
	{}

ResourceItem * StructArrayStructItem::NewResourceItem()
	{
	return new StructArrayResourceItem( this);
	}

StructArrayStructItem::~StructArrayStructItem()
	{}

// StructItemArray

StructItemArray::StructItemArray()
	{}
	
StructItemArray::~StructItemArray()
	{
	DeleteAll();
	}
	
void StructItemArray::Add( StructItem * pNewItem)
	{
	StructItemArrayIterator next( * this);
	StructItem * p;
	
	while( ( p = next() ) != NULL)
		{
		if ( p->iLabel == pNewItem->iLabel)
			{
			ErrorHandler::OutputErrorLine( "Label already in this structure.");
			exit(1);
			}
		}
	Array::Add( pNewItem);
	}

// StructItemArrayIterator

StructItemArrayIterator::StructItemArrayIterator(const StructItemArray& aArray):
	ArrayIterator(aArray)
	{}

StructItem* StructItemArrayIterator::operator()()
	{
	return ( StructItem *) ArrayIterator::operator()();
	}
	
// StructHeader

StructHeader::StructHeader(String aLabelToSet):
	iLabel(aLabelToSet),
	iLenType( 0)
	{}

StructHeader::StructHeader(String aLabelToSet,DataType aLenTypeToSet):
	iLabel(aLabelToSet),
	iLenType(aLenTypeToSet)
	{}

// StructHeaderArray

int StructHeaderArray::iInUse = 0;

StructHeaderArray::StructHeaderArray()
	{
	assert( iInUse == 0);
	iInUse = 1;
	}

StructHeaderArray::~StructHeaderArray()
	{
	assert( iInUse == 1);
	iInUse = 0;
	DeleteAll();
	}

void StructHeaderArray::Add( StructHeader * pNewItem)
	{
	StructHeaderArrayIterator next( * this);
	StructHeader * p;
	
	while( ( p = next() ) != NULL)
		{
		if ( p->iLabel == pNewItem->iLabel)
			{
			ErrorHandler::OutputErrorLine( "STRUCT with this name already stored");
			exit(1);
			}
		}
	Array::Add( pNewItem);
	}

StructHeader * StructHeaderArray::Find( const String & LabelSought)
	{
	StructHeaderArrayIterator next( * this);
	StructHeader * p;
	
	while( ( p = next() ) != NULL)
		if ( p->iLabel == LabelSought)
			return p;
	
	ErrorHandler::OutputErrorLine( "Label not found");
	exit(1);
	}

// StructHeaderArrayIterator

StructHeaderArrayIterator::StructHeaderArrayIterator(const StructHeaderArray& aArray):
	ArrayIterator(aArray)
	{}

StructHeader * StructHeaderArrayIterator::operator()()
	{
	return (StructHeader*)ArrayIterator::operator()();
	}
